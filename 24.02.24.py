'''
오늘 한 것 복습정리

키워드 인수

딕셔너리 언패킹

키워드 인수 사용하는 가변인수함수

매개변수 초기값 지정

재귀호출

global전역함수

람다표현식 사용

map 함수와 람다와의 활용'''

def fun1(a,b,c):
    print(a,b,c)

fun1(10,20,30)
fun1(c=10,b=40,a=50) # 키워드로 인수를 지정해주는 방식




def fun2(a,b,c):
    print(a,b,c,sep="     ")

an = {"a":10,"b":5.5,"c":11}
fun2(**an)
# 딕셔너리 언패킹을 할 때 **를 붙인다.
# 애스터리스크를 한개만 붙이면 키 값만 가져오기에 꼭 두개를 붙이도록 한다.



# 키워드 인수를 사용하는 가변인자변수에서 매개변수는 키워드 아규먼트를 줄여 관례적으로 **kwargs 를 쓴다.

# def fun(**kwargs):
#     for i,j in kwargs.items(): # items를 붙여야 함. 겁나게 헷갈린다 진짜로@!!!!!
#         print(i,j)

# a = {"이름":"햄스터","별명":"힙스터","나이":25}
# b = {"이름":"정재형","나이":25}
# c = {"이름":"박의진"}

# fun(**a)
# fun(**b)
# fun(**c)

def fun(**kwargs):
    for i,j in kwargs.items():
        print(i,j)

fun(**{"이름":"정재형"})
fun(**{"이름":"햄스터","나이":"2개월"})

# .item() 를 붙여야 딕셔너리 자료형의 키값과 내용물에 접근이 가능하다.




# 매개변수 초기화 : def 함수이름(매개변수 = 값):
# 함수 호출 시 항상 인수를 넣어 값을 전달했었는데 초기값을 입력 해 두면 인수 생략이 가능하다.
# 매개변수에 초기값이 있더라도 인수로 값을 넣으면 해당값이 전달된다.

def a(a,b,c=10):
    print(a,b,c)

a(1,1) # 3번 째 인자가 공백이면 초기화 된 10이 출력되고
a(1,2,3) # 3을 넣으니 포기하된 값이 무시되고 3이 출력됨.




# 재귀호출과 global 전역함수

# 재귀호출 : 힘수 안에서 자기자신을 호출하는 방식으로 알고리즘 구현에 잘 사용한다
# 파이썬에서 최대 재귀 깊이가 1000이라 1000번 이상 반복 시 오류를 발생시킴을 알아두자
# 그러므로 재귀하수는 꼭 종료조건을 넣어줘야 함

def fun(a):
    if a == 0:
        return
    print("안녕")
    fun(a-1)

fun(10)


# global은 전역함수를 만드는 것인데 사실 프로그램 해석에 혼란을 주가애 추천하지는 않는 방법이다.
# 우선 함수 내에서 선언하든 외부의 변수를 함수 내에서 쓰든 함수에서 선언 시 무조건 global을 붙인다.
# 함수 밖에서 global 변수 선언 시 사실 global을 붙이지 않아도 된다. 다만 이 변수를 함수에서 사용할 시
# 해당 함수 줄에 global 변수이름을 작성해야 내부 함수 이름인지 외부의 전역변수인지 구분이 된다.





# 재귀함수를 이용하여 팩토리얼 만들기!!

ans = 1

def fac(a):
    global ans
    if a<0:
        return
    if a == 1:
        return print(ans*1)
    else:
        ans *= a
        fac(a-1)


fac(5)

'''
람다 표현식 : lambda 매개변수들 : 반환할 식

이상태로만 하면 함수 호출이 안된다.
함수호출을 원하면
람다바로호출 : (lambda 매개변수들 : 반환할 식)(인수)
로 해야 한다.

람다 표현식은 이름이 없는 함수를 만들기에 익명함수라고도 한다
익명함수 호출을 원하면 변수에 람다 표현식을 할당함

변수 = lambda 매개변수들 : 반환할 식

람다 안에는 새 변수를 만들 수 없음.
변수가 필요한 경우 def를 사용하는게 나음.
변수 할당이 안되므로 -= 나 += 같은것도 안되겠지??

람다식을 map 함수와 함께 인수로 사용할 수 있다.

'''

def fun(x):
    return x+10

print(list(map(fun,[1,2,3])))

print(list(map(lambda x:x+10,[1,2,3]))) # 위 식보다 간결히 쓸 수 있음.